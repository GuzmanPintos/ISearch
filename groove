#!/usr/bin/python3
import argparse
import os
import urllib.parse

import requests
import urwid

import Search.bing as bing
import Search.duck as duck
import Search.google as google

engines = {
    'google': google,
    "duck": duck,
    'bing': bing,
}


class DownloadException(Exception):
    """
    Base class foe download file exceptions
    """
    pass


class Cmd:
    def __init__(self, query, engine, **kwargs):
        """
        Groove cmd class
        """
        self.kwargs = kwargs
        self.engine = engines.get(engine)
        self.query = query

    def cmd_search(self):
        try:
            self.results = self.engine.Search(self.query, **self.kwargs)
        except self.engine.NoInternetError:
            print("No internet quiting")
            quit(1)

    def pprint_cmd(self, colours=True):
        if colours:
            red = '\033[91m'
            bold = '\033[1m'
            underl = '\033[4m'
            blue = '\033[94m'
            endc = '\033[0m'
        else:
            red = ''
            bold = ''
            underl = ''
            blue = ''
            endc = ''
        if not hasattr(self, 'results'):
            self.cmd_search()
        try:
            for title, link, text in self.results.next():
                print(red + bold + underl + title + endc)
                print(blue + link + endc)
                print(text + '\n')
        # DuckDuckGo is re-writen in order to support bangs
        # So this exception handler is for DuckDuckGo
        except self.engine.NoInternetError:
            print("No internet quiting")
            quit(1)


class InteractiveCmd:
    def __init__(self):
        self.palette = (
            ('titlebar', 'dark red,bold,underline', 'black'),
            ('quit', 'light red,bold,underline', 'black'),

            ('alert', 'dark red,bold', ''),
            ('info', 'light blue,bold,blink', ''),

            ('query', 'bold', 'black'),

            ('google', 'light red,bold', ''),
            ('duck', 'light green,bold', ''),
            ('bing', 'light blue,bold', ''),

            ('title', 'light red, bold,underline', ''),
            ('link', 'light blue,underline', ''),

            ('download_title', 'light green, bold,underline', ''),
            ('download_edt', 'bold', ''),
            ('download_btn', 'dark magenta,bold', ''),
            ('color', 'light green,bold', '')
        )
        # Header
        self.header = urwid.Text(('titlebar', u'GROOVE'), align='center')

        # Body
        self.result_bar = urwid.Text(u"Input a query and press enter.\nResults will be displayed \u2193")
        padding = urwid.Padding(self.result_bar, left=2, right=2)
        self.line_box = urwid.LineBox(padding, title='Result bar')

        # Options for search engines.
        opt_grp = []
        self.google_opt = urwid.RadioButton(opt_grp, 'Google', on_state_change=self.det_search_module, user_data=None)
        google_opt = urwid.AttrMap(self.google_opt, 'google')
        self.bing_opt = urwid.RadioButton(opt_grp, 'Bing', on_state_change=self.det_search_module, user_data=None)
        bing_opt = urwid.AttrMap(self.bing_opt, 'bing')
        self.duck_opt = urwid.RadioButton(opt_grp, 'DuckDuckGo', on_state_change=self.det_search_module, user_data=None)
        duck_opt = urwid.AttrMap(self.duck_opt, 'duck')
        opt = urwid.GridFlow([google_opt, bing_opt, duck_opt], 20, 4, 1, align='center')

        # TODO:Add a previous button.
        # Next button
        next_btn = urwid.GridFlow([urwid.Button('Next', on_press=self.next)], 8, 0, 0, align='center')

        # Download options
        download_title = urwid.Text(('download_title', "Download a File"), align='center')
        self.download_url = urwid.Edit("URL >> ")
        # Save the file in Downloads directory. unless explicitly told otherwise!
        self.download_path = urwid.Edit('Path >> ', edit_text="/home/" + os.getlogin() + "/Downloads")
        download_btn = urwid.Button("Download", on_press=self.download_file)

        download_opt = urwid.LineBox(
            urwid.Pile([download_title,
                        urwid.AttrMap(self.download_url, 'download_edt'),
                        urwid.AttrMap(self.download_path, 'download_edt'),
                        urwid.AttrMap(urwid.GridFlow([download_btn], 13, 0, 0, align='center'), 'download_btn')

                        ])
        )
        btn_pile = urwid.Pile([next_btn])

        body = urwid.Columns([('weight', 5, self.line_box),
                              urwid.Pile([urwid.LineBox(opt),
                                          urwid.Text(''),
                                          urwid.LineBox(btn_pile),
                                          urwid.Text(''),
                                          download_opt
                                          ])
                              ])

        # Footer
        self.query = urwid.Edit('Query>>> ')
        column_bar = urwid.Columns([('weight', 5, urwid.LineBox(urwid.AttrMap(self.query, 'query'))),
                                    urwid.Text('')],
                                   dividechars=6)
        # Exit button with Grid for compactness.
        exit_btn = urwid.GridFlow([urwid.AttrMap(urwid.Button("Exit", on_press=self.exit), 'quit')],
                                  cell_width=8,
                                  h_sep=0,
                                  v_sep=0,
                                  align='center')
        footer_pile = urwid.Pile([column_bar, urwid.Text(''), exit_btn])

        # Assemble widgets
        # Set the focus on the footer
        self.frame = urwid.Frame(header=self.header, body=urwid.Filler(body, valign='top', top=1, bottom=1),
                                 footer=footer_pile,
                                 focus_part='footer')

    def download_file(self, nothing=None):
        if not self.download_url.get_edit_text().strip(""):
            self.result_bar.set_text(('alert', "ERROR:No url provided"))
        else:
            url = self.download_url.get_edit_text()
            if not url.startswith("http://"):
                url = "http://" + url
            try:
                data = requests.get(url)
                # Raise an error if the status code lies above 400
                data.raise_for_status()
            except Exception as e:
                self.result_bar.set_text(('alert', e.__str__()))
            else:
                _path = self.download_path.get_edit_text()
                try:
                    # Create a file and then close, like the touch program
                    open(_path, mode='x').close()
                except IsADirectoryError:
                    os.makedirs(_path, exist_ok=True)
                except PermissionError:
                    self.result_bar.set_text(("alert", "Permission denied"))
                except (FileExistsError, FileNotFoundError):
                    pass
                if os.path.isfile(_path):
                    path = _path
                elif os.path.isdir(_path):
                    # Get the filename from the url or if no filename set it to index.html
                    # BUG: Sometimes it may save the file using the ip address
                    filename = urllib.parse.urlsplit(self.download_url.get_edit_text()).path.rsplit("/")[-1:][0] \
                               or "index.html"
                    path = _path + "/" + filename
                else:
                    raise DownloadException("Path is malformed")
                self.result_bar.set_text(("color", 'Downloading from {}'.format(url)))
                try:
                    with open(path, "wb") as wfile:
                        # Chunk everything in 1 mb files
                        for chunk in data.iter_content(1048576):
                            wfile.write(chunk)
                except Exception as e:
                    self.result_bar.set_text(('alert', e.__str__()))
                else:
                    self.result_bar.set_text(("color", 'File saved at {}'.format(path)))

    def previous(self):
        pass

    def next(self, nothing=None):
        """
        Fetch next results
        :param nothing:
        :return:
        """
        tbp = []
        self.det_search_module()
        if hasattr(self, 'searcher'):
            try:
                for title, link, text in self.searcher.next():
                    tbp.append(('title', title + '\n'))
                    tbp.append(('link', link + '\n'))
                    tbp.append(('', text + '\n\n'))
                self.result_bar.set_text(tbp)
            except ConnectionError:
                self.result_bar.set_text(('alert', "ERROR:No Internet connection detected"))
        else:
            self.search()

    def det_search_module(self, nothing=None, nothing1=None):
        """
        Determine search module to use
        """
        if self.google_opt.state:
            self.search_m = google
        elif self.bing_opt.state:
            self.search_m = bing
        else:
            self.search_m = duck

    def search(self, nothing=None):
        """
        Fetch and print results
        """
        query = self.query.get_edit_text()
        if query is '' or query.strip(" ") is '':
            self.result_bar.set_text(('alert', 'ERROR:Input a value into the query box'))
        else:
            self.det_search_module()
            self.result_bar.set_text(('info', "Searching for '{}' using {}".format(query,
                                                                                   self.search_m.__name__)))
            tbp = []
            if query.strip(" ").startswith("!") and "Duck" in self.search_m.__name__:
                # DuckDuckGo bang request
                self.search_m.Search(query).handle_bang()
                self.result_bar.set_text([("info", "Now that's a !bang\n"),
                                          ('', "Check out https://api.duckduckgo.com/bang for more info")])
            else:
                # Normal request
                self.line_box.set_title(self.search_m.__name__ + " results for '{query}'".format(query=query))
                try:
                    self.searcher = self.search_m.Search(query)
                    for title, link, text in self.searcher.next():
                        tbp.append(('title', title + '\n'))
                        tbp.append(('link', link + '\n'))
                        tbp.append(('', text + '\n\n'))
                    self.result_bar.set_text(tbp)
                except ConnectionError:
                    self.result_bar.set_text(('alert', "ERROR:No Internet connection detected"))

    def exit(self, nothing=None):
        """
        Exit mainloop
        """
        raise urwid.ExitMainLoop()

    def handle_input(self, keypress):
        """
        Handle  untied input
        :param keypress: Key pressed
        :return:
        """
        if keypress == 'enter':
            self.search()
        if keypress == 'esc':
            self.exit()


def main():
    parser = argparse.ArgumentParser(prog='Groove',
                                     description="Groove command line options",
                                     epilog="Submit bugs at https://www.github.com/stevetyler254/Groove.git",
                                     formatter_class=argparse.RawTextHelpFormatter
                                     )
    parser.add_argument("--disable-colours", action='store_true',
                        help="Disable colour output\n\n")
    parser.add_argument("-i", '--interactive', action='store_true',
                        help='Enter Groove interactive mode\n\n')

    parser.add_argument("-b", "--bing",
                        help="Search using Bing", metavar="")
    parser.add_argument("-d", "--duck",
                        help="Search using DuckDuckGo", metavar="")
    parser.add_argument("-g", '--google',
                        help='Search using Google\n\n', metavar="")
    parser.add_argument("-v", "--version", action="version", version="0.1.0")
    options = parser.parse_args()
    if options.bing:
        Cmd(options.bing, 'bing').pprint_cmd(colours=options.disable_colours)
    elif options.duck:
        Cmd(options.duck, 'duck').pprint_cmd(colours=options.disable_colours)
    elif options.google:
        Cmd(options.google, 'google').pprint_cmd(colours=options.disable_colours)
    elif options.interactive:
        interactive = InteractiveCmd()
        urwid.MainLoop(interactive.frame, interactive.palette, unhandled_input=interactive.handle_input).run()
    else:
        parser.print_help()


if __name__ == '__main__':
    main()
